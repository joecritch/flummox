{"version":3,"sources":["../../src/addons/FluxComponentNative.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiDO,KAAK,2BAAM,cAAc;;2CACkB,+BAA+B;;IAAxE,eAAe,gCAAf,eAAe;IAAE,gBAAgB,gCAAhB,gBAAgB;;IACnC,MAAM,2BAAM,eAAe;;AAElC,IAAM,aAAa,GAAG,KAAK,CAAC,WAAW,CAAC;;;AACtC,iBAAe,EAAA,2BAAG;AAChB,WAAO,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;GACvE;;AAED,WAAS,EAAA,mBAAC,KAAK,EAAE;AACf,WAAO,KAAK,CAAC,MAAM,CAAC,cAAc,CAChC,KAAK,EACL,IAAI,CAAC,aAAa,EAAE,CACrB,CAAC;GACH;;AAED,eAAa,EAAA,yBAAG;iBAOM,IAAI,CAAC,KAAK;QAL5B,QAAQ,UAAR,QAAQ;QACR,MAAM,UAAN,MAAM;QACN,eAAe,UAAf,eAAe;QACf,WAAW,UAAX,WAAW;QACX,IAAI,UAAJ,IAAI;;QACD,UAAU;;AAEf,WAAO,MAAM,CACX,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,EAAE,EACxB,IAAI,CAAC,KAAK,EACV,UAAU,CACX,CAAC;GACH;;AAED,QAAM;;;;;;;;;;KAAA,YAAG;iBACsB,IAAI,CAAC,KAAK;QAA/B,QAAQ,UAAR,QAAQ;QAAE,MAAM,UAAN,MAAM;;AAExB,QAAI,OAAO,MAAM,KAAK,UAAU,EAAE;AAChC,aAAO,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;KACrD;;AAED,QAAI,CAAC,QAAQ,EAAE,OAAO,IAAI,CAAC;;AAE3B,QAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;AAC5B,UAAM,KAAK,GAAG,QAAQ,CAAC;AACvB,aAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;KAC9B,MAAM;AACL,aAAO;AAAC,aAAK,CAAC,IAAI;;QAAE,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC;OAAc,CAAC;KAChF;GACF,CAAA;CACF,CAAC,CAAC;;AAEH,MAAM,CACJ,aAAa,CAAC,SAAS,EACvB,eAAe,CAChB,CAAC;;AAEF,MAAM,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;;iBAEzB,aAAa","file":"src/addons/FluxComponentNative.js","sourcesContent":["/**\n * Flux Component\n *\n * Component form of fluxMixin. Uses fluxMixin as part of its implementation,\n * so requires a flux instance to be provided as either context or a prop.\n *\n * Like fluxMixin, children are given access to the flux instance via\n * `context.flux`. Use this near the top of your app hierarchy and all children\n * will have easy access to the flux instance (including, of course, other\n * Flux components!):\n *\n * <FluxComponent flux={flux}>\n *    ...the rest of your app\n * </FluxComponent>\n *\n * Now any child can access the flux instance again like this:\n *\n * <FluxComponent>\n *    ...children\n * </FluxComponent>\n *\n * We don't need the flux prop this time because flux is already part of\n * the context.\n *\n * Additionally, immediate children are given a `flux` prop.\n *\n * The component has an optional prop `connectToStores`, which is -- you guessed\n * it -- passed directly to fluxMixin's `connectToStores()` function and\n * set as the initial state. The component's state is injected as props to\n * child components.\n *\n * The practical upshot of all this is that fluxMixin, state changes, and\n * context are now simply implementation details. Among other things, this means\n * you can write your components as plain ES6 classes. Here's an example:\n *\n * class ParentComponent extends React.Component {\n *\n *   render() {\n *     <FluxComponent connectToStores=\"fooStore\">\n *       <ChildComponent />\n *     </FluxComponent>\n *   }\n *\n * }\n *\n * ChildComponent in this example has prop `flux` containing the flux instance,\n * and props that sync with each of the state keys of fooStore.\n */\n\nimport React from 'react-native';\nimport { instanceMethods, staticProperties } from './reactNativeComponentMethods';\nimport assign from 'object-assign';\n\nconst FluxComponent = React.createClass({\n  getInitialState() {\n    return this.connectToStores(props.connectToStores, props.stateGetter);\n  },\n\n  wrapChild(child) {\n    return React.addons.cloneWithProps(\n      child,\n      this.getChildProps()\n    );\n  },\n\n  getChildProps() {\n    const {\n      children,\n      render,\n      connectToStores,\n      stateGetter,\n      flux,\n      ...extraProps } = this.props;\n\n    return assign(\n      { flux: this.getFlux() },\n      this.state,\n      extraProps\n    );\n  },\n\n  render() {\n    const { children, render } = this.props;\n\n    if (typeof render === 'function') {\n      return render(this.getChildProps(), this.getFlux());\n    }\n\n    if (!children) return null;\n\n    if (!Array.isArray(children)) {\n      const child = children;\n      return this.wrapChild(child);\n    } else {\n      return <React.View>{React.Children.map(children, this.wrapChild)}</React.View>;\n    }\n  }\n});\n\nassign(\n  FluxComponent.prototype,\n  instanceMethods\n);\n\nassign(FluxComponent, staticProperties);\n\nexport default FluxComponent;\n"]}