{"version":3,"sources":["../../src/__tests__/exampleFlux-test.js"],"names":[],"mappings":";;;;;;;;;;;;oBAAwC,SAAS;;IAAxC,OAAO,SAAP,OAAO;IAAE,KAAK,SAAL,KAAK;IAAE,OAAO,SAAP,OAAO;;AAEhC,QAAQ,CAAC,WAAW,EAAE,YAAM;;;;;AAK1B,UAAQ,CAAC,UAAU,EAAE,YAAM;;;;;;;;;;;QAUnB,cAAc;eAAd,cAAc;8BAAd,cAAc;;;;;;;gBAAd,cAAc;;mBAAd,cAAc;AAClB,kBAAU;iBAAA,oBAAC,OAAO,EAAE;;;AAGlB,mBAAO,OAAO,CAAC;WAChB;;;;aALG,cAAc;OAAS,OAAO;;;;;;;;;;;;;;;;;;;QAwB9B,YAAY;;;;;AAIL,eAJP,YAAY,CAIJ,IAAI,EAAE;8BAJd,YAAY;;;AAOd,mCAPE,YAAY,6CAON;;AAER,YAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AACnD,YAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;AAChE,YAAI,CAAC,cAAc,GAAG,CAAC,CAAC;;AAExB,YAAI,CAAC,KAAK,GAAG,EAAE,CAAC;OACjB;;gBAdG,YAAY;;mBAAZ,YAAY;AAgBhB,wBAAgB;iBAAA,0BAAC,OAAO,EAAE;AACxB,gBAAM,EAAE,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;;AAEjC,gBAAI,CAAC,QAAQ,qBACV,EAAE,EAAG;AACJ,qBAAO,EAAP,OAAO;AACP,gBAAE,EAAF,EAAE,EACH,EACD,CAAC;WACJ;;;;aAzBG,YAAY;OAAS,KAAK;;;;;;;QAiC1B,IAAI;AACG,eADP,IAAI,GACM;8BADV,IAAI;;AAEN,mCAFE,IAAI,6CAEE;;;;AAIR,YAAI,CAAC,aAAa,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;;;;AAI/C,YAAI,CAAC,WAAW,CAAC,UAAU,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;OAClD;;gBAXG,IAAI;;aAAJ,IAAI;OAAS,OAAO;;;;;;;;;AAqB1B,MAAE,CAAC,sBAAsB,EAAE,YAAM;AAC/B,UAAM,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;AACxB,UAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;AAC/C,UAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;;AAEnD,YAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;;AAE7C,oBAAc,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;AAC3C,YAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,qBACrC,CAAC,EAAG;AACH,eAAO,EAAE,eAAe;AACxB,UAAE,EAAE,CAAC,EACN,EACD,CAAC;KACJ,CAAC,CAAC;GACJ,CAAC,CAAC;CAEJ,CAAC,CAAC","file":"src/__tests__/exampleFlux-test.js","sourcesContent":["import { Flummox, Store, Actions } from '../Flux';\n\ndescribe('Examples:', () => {\n\n  /**\n   * A simple Flummox example\n   */\n  describe('Messages', () => {\n\n    /**\n     * To create some actions, create a new class that extends from the base\n     * Actions class. Methods on the class's prototype will be converted into\n     * actions, each with its own action id.\n     *\n     * In this example, calling `newMessage` will fire the dispatcher, with\n     * a payload containing the passed message content. Easy!\n     */\n    class MessageActions extends Actions {\n      newMessage(content) {\n\n        // The return value from the action is sent to the dispatcher.\n        return content;\n      }\n    }\n\n    /**\n     * Now we need to a Store that will receive payloads from the dispatcher\n     * and update itself accordingly. Like before, create a new class that\n     * extends from the Store class.\n     *\n     * Stores are automatically registered with the dispatcher, but rather than\n     * using a giant `switch` statement to check for specific action types, we\n     * register handlers with action ids, or with a reference to the action\n     * itself.\n     *\n     * Stores have a React-inspired API for managing state. Use `this.setState`\n     * to update state within your handlers. Multiple calls to `this.setState`\n     * within the same handler will be batched. A change event will fire after\n     * the batched updates are applied. Your view controllers can listen\n     * for change events using the EventEmitter API.\n     */\n    class MessageStore extends Store {\n\n      // Note that passing a flux instance to the constructor is not required;\n      // we do it here so we have access to any action ids we're interested in.\n      constructor(flux) {\n\n        // Don't forget to call the super constructor\n        super();\n\n        const messageActions = flux.getActions('messages');\n        this.register(messageActions.newMessage, this.handleNewMessage);\n        this.messageCounter = 0;\n\n        this.state = {};\n      }\n\n      handleNewMessage(content) {\n        const id = this.messageCounter++;\n\n        this.setState({\n          [id]: {\n            content,\n            id,\n          },\n        });\n      }\n    }\n\n\n    /**\n     * Here's where it all comes together. Extend from the base Flummox class\n     * to create a class that encapsulates your entire flux set-up.\n     */\n    class Flux extends Flummox {\n      constructor() {\n        super();\n\n        // Create actions first so our store can reference them in\n        // its constructor\n        this.createActions('messages', MessageActions);\n\n        // Extra arguments are sent to the store's constructor. Here, we're\n        // padding a reference to this flux instance\n        this.createStore('messages', MessageStore, this);\n      }\n    }\n\n    /**\n     * And that's it! No need for singletons or global references -- just create\n     * a new instance.\n     *\n     * Now let's test it.\n     */\n\n    it('creates new messages', () => {\n      const flux = new Flux();\n      const messageStore = flux.getStore('messages');\n      const messageActions = flux.getActions('messages');\n\n      expect(messageStore.state).to.deep.equal({});\n\n      messageActions.newMessage('Hello, world!');\n      expect(messageStore.state).to.deep.equal({\n        [0]: {\n          content: 'Hello, world!',\n          id: 0,\n        },\n      });\n    });\n  });\n\n});\n"]}